<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Alert Suppression Inspector</title>
    <link rel="icon" href="NyanCat.ico" type="image/x-icon">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js" type="text/javascript" charset="utf-8"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        h1 {
            background-color: #0515f0;
            color: #fff;
            padding: 20px;
            margin: 0;
        }
        main {
            padding: 20px;
            margin: 20px auto;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            width: 90%;
            max-width: 1000px;
        }
        .editor {
            height: 300px;
            margin-bottom: 20px;
        }
        button {
            background-color: #2e06df;
            color: #fff;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        h3 {
            padding: 8px 0;
            font-size: 18px;
        }
        p {
            margin: 5px 0;
            font-size: 16px;
            line-height: 1.4;
        }
        .match, .mismatch {
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        .match {
            background-color: #f0fff0;
            border-left: 4px solid #45a049;
        }
        .mismatch {
            background-color: #fff0f0;
            color: #d00;
            border-left: 4px solid #d00;
        }
        .summary {
            font-size: 18px;
            font-weight: bold;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .success {
            background-color: #e6ffe6;
            color: #008000;
        }
        .failure {
            background-color: #ffe6e6;
            color: #d00;
        }
        .tabs {
            display: flex;
            margin-bottom: 10px;
        }
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border: 1px solid #ddd;
            background-color: #f4f4f4;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
        }
        .tab.active {
            background-color: #0515f0;
            color: white;
            border-bottom: none;
        }
        .settings {
            margin: 10px 0;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .config-check {
            margin-right: 15px;
        }
    </style>
</head>
<body>
    <h1>Alert Suppression Inspector</h1>
    <main>
        <div class="tabs">
            <div class="tab active" onclick="switchTab('input')">Input Data</div>
        </div>
        
        <div id="inputTab">
            <label for="alertEditor"><strong>Alert Data:</strong> (paste alert JSON or key-value format)</label>
            <div id="alertEditor" class="editor"></div>

            <label for="ruleEditor"><strong>Suppression Rule:</strong> (paste rule JSON)</label>
            <div id="ruleEditor" class="editor"></div>

            <div class="settings">
                <label class="config-check">
                    <input type="checkbox" id="strictCaseCheck" checked>
                    <span>Strict case sensitivity (APPLES ≠ apples)</span>
                </label>
                <label class="config-check">
                    <input type="checkbox" id="showDetailsCheck" checked>
                    <span>Show detailed field comparisons</span>
                </label>
            </div>

            <button onclick="processData()">Validate Suppression</button>
        </div>
        
        
        
        <div id="summary"></div>
        <div id="results"></div>
    </main>
    <script>
        // Initialize Ace editor for Alert Data
        var alertEditor = ace.edit("alertEditor");
        alertEditor.setTheme("ace/theme/monokai");
        alertEditor.session.setMode("ace/mode/text");
        
        // Initialize Ace editor for Suppression Rule
        var ruleEditor = ace.edit("ruleEditor");
        ruleEditor.setTheme("ace/theme/monokai");
        ruleEditor.session.setMode("ace/mode/json");
        
        // Field mappings for better display
        const fieldMappings = {
            "ip": "IP Address",
            "os": "Operating System",
            "uid": "Process Owner UID",
            "name": "Process Name",
            "path": "File Path",
            "sha1": "File SHA1",
            "type": "Item Type",
            "owner": "Process Owner",
            "sha256": "File SHA256",
            "eppType": "EPP Type",
            "hostname": "Hostname",
            "ruleName": "Rule Name",
            "issuerName": "File Signature Issuer",
            "sourceType": "Alert Type",
            "avPositives": "AV Hits",
            "commandLine": "Process Command Line",
            "avThreatName": "AV Threat Name",
            "ruleSeverity": "Severity",
            "threatStatus": "Threat Status",
            "targetGroupId": "Location Name",
            "organizationId": "Organization Name",
            "threatCategory": "Threat Category",
            "parentProcessName": "Parent Process Name",
            "grandParentProcessName": "Grand Parent Process Name",
            "signature.issuerName": "File Signature Issuer"
        };
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
            
            if (tabName === 'input') {
                document.getElementById('inputTab').style.display = 'block';
                document.getElementById('samplesTab').style.display = 'none';
            } else {
                document.getElementById('inputTab').style.display = 'none';
                document.getElementById('samplesTab').style.display = 'block';
            }
        }
        
        function processData() {
            const summaryDiv = document.getElementById('summary');
            const resultsDiv = document.getElementById('results');
            summaryDiv.innerHTML = '';
            resultsDiv.innerHTML = '';
            
            // Get configuration options
            const strictCase = document.getElementById('strictCaseCheck').checked;
            const showDetails = document.getElementById('showDetailsCheck').checked;
            
            try {
                // Parse alert data (handle both JSON and key-value format)
                let alertData;
                const alertText = alertEditor.getValue().trim();
                
                try {
                    // Try parsing as JSON first
                    alertData = JSON.parse(alertText);
                } catch (e) {
                    // If not valid JSON, try key-value format
                    alertData = parseKeyValueFormat(alertText);
                }
                
                // Parse rule data (always JSON)
                let ruleData;
                try {
                    const ruleText = ruleEditor.getValue().trim();
                    // Check if the rule JSON starts with [ or {
                    if (ruleText.startsWith('[')) {
                        // If it's an array, take the first rule
                        ruleData = JSON.parse(ruleText)[0];
                    } else {
                        ruleData = JSON.parse(ruleText);
                    }
                } catch (e) {
                    throw new Error('Invalid Rule JSON: ' + e.message);
                }
                
                // Find matches between alert and rule
                const results = findMatches(alertData, ruleData, strictCase);
                
                // Display summary
                displaySummary(results, ruleData.name);
                
                // Display detailed results if enabled
                if (showDetails) {
                    displayMatches(results);
                }
                
                console.log("Alert Data:", alertData);
                console.log("Rule Data:", ruleData);
                console.log("Results:", results);
            } catch (e) {
                summaryDiv.innerHTML = `<div class="summary failure">Error: ${e.message}</div>`;
            }
        }
        
        function parseKeyValueFormat(text) {
            const lines = text.split('\n');
            const data = {};
            
            lines.forEach(line => {
                line = line.trim();
                if (!line) return;
                
                const colonIndex = line.indexOf(':');
                if (colonIndex === -1) return;
                
                const key = line.substring(0, colonIndex).trim();
                const value = line.substring(colonIndex + 1).trim();
                
                // Handle nested properties (e.g., signature.issuerName)
                if (key.includes('.')) {
                    const parts = key.split('.');
                    let current = data;
                    for (let i = 0; i < parts.length - 1; i++) {
                        if (!current[parts[i]]) {
                            current[parts[i]] = {};
                        }
                        current = current[parts[i]];
                    }
                    current[parts[parts.length - 1]] = value;
                } else {
                    data[key] = value;
                }
            });
            
            return data;
        }
        
        function findMatches(alertData, ruleData, strictCase) {
            let results = {
                matches: [],
                mismatches: [],
                totals: {
                    active: 0,
                    matched: 0
                }
            };
            
            const metadata = ruleData.metadata || {};
            
            // Process regular fields
            for (const key in metadata) {
                if (key === 'signature') continue; // Skip signature, handle it specially below
                
                const metadataItem = metadata[key];
                if (metadataItem.active) {
                    results.totals.active++;
                    
                    const alertValue = getAlertValue(alertData, key);
                    const ruleValue = metadataItem.value;
                    const operator = metadataItem.operator || '==';
                    const dataType = metadataItem.dataType || 'string';
                    
                    // Handle empty or missing values
                    if (alertValue === undefined || alertValue === null || alertValue === '') {
                        results.mismatches.push({
                            field: key,
                            reason: `Missing or empty value for ${fieldMappings[key] || key}`,
                            alertValue: alertValue === '' ? '(empty string)' : '(no value)',
                            ruleValue
                        });
                        continue;
                    }
                    
                    // Compare values
                    if (compareValues(alertValue, ruleValue, operator, dataType, strictCase)) {
                        results.matches.push({
                            field: key,
                            alertValue,
                            ruleValue,
                            operator
                        });
                        results.totals.matched++;
                    } else {
                        results.mismatches.push({
                            field: key,
                            reason: `Value mismatch for ${fieldMappings[key] || key}`,
                            alertValue,
                            ruleValue,
                            operator
                        });
                    }
                }
            }
            
            // Handle signature separately (it's nested)
            if (metadata.signature && metadata.signature.issuerName && metadata.signature.issuerName.active) {
                results.totals.active++;
                
                const alertValue = alertData.signature?.issuerName;
                const ruleValue = metadata.signature.issuerName.value;
                const operator = metadata.signature.issuerName.operator || '==';
                
                if (alertValue === undefined || alertValue === null || alertValue === '') {
                    results.mismatches.push({
                        field: 'signature.issuerName',
                        reason: 'Missing or empty value for File Signature Issuer',
                        alertValue: alertValue === '' ? '(empty string)' : '(no value)',
                        ruleValue
                    });
                } else if (compareValues(alertValue, ruleValue, operator, 'string', strictCase)) {
                    results.matches.push({
                        field: 'signature.issuerName',
                        alertValue,
                        ruleValue,
                        operator
                    });
                    results.totals.matched++;
                } else {
                    results.mismatches.push({
                        field: 'signature.issuerName',
                        reason: 'Value mismatch for File Signature Issuer',
                        alertValue,
                        ruleValue,
                        operator
                    });
                }
            }
            
            return results;
        }
        
        function getAlertValue(alertData, key) {
            // Handle special cases and nested properties
            if (key.includes('.')) {
                const parts = key.split('.');
                let value = alertData;
                for (const part of parts) {
                    if (!value || value[part] === undefined) return undefined;
                    value = value[part];
                }
                return value;
            }
            
            return alertData[key];
        }
        
        function compareValues(alertValue, ruleValue, operator, dataType, strictCase) {
            // Convert to appropriate type
            if (dataType === 'number') {
                alertValue = parseFloat(alertValue);
                ruleValue = parseFloat(ruleValue);
                if (isNaN(alertValue) || isNaN(ruleValue)) {
                    return false;
                }
            } else {
                // For string comparison
                alertValue = String(alertValue);
                ruleValue = String(ruleValue);
                
                // For wildcards or case-insensitive comparison, convert to lowercase
                if (!strictCase || ruleValue.includes('*')) {
                    alertValue = alertValue.toLowerCase();
                    ruleValue = ruleValue.toLowerCase();
                }
            }
            
            // Check for wildcards
            if (typeof ruleValue === 'string' && ruleValue.includes('*')) {
                const escapedRuleValue = ruleValue
                    .replace(/[.+?^${}()|[\]\\]/g, '\\$&') // Escape special regex chars except *
                    .replace(/\*/g, '.*'); // Replace * with .*
                
                const regexFlags = strictCase ? '' : 'i';
                const regex = new RegExp(`^${escapedRuleValue}$`, regexFlags);
                return regex.test(alertValue);
            }
            
            // Normal comparison
            switch (operator) {
                case '=':
                case '==':
                    return alertValue == ruleValue;
                case '<':
                    return alertValue < ruleValue;
                case '>':
                    return alertValue > ruleValue;
                case '<=':
                    return alertValue <= ruleValue;
                case '>=':
                    return alertValue >= ruleValue;
                case '!=':
                    return alertValue != ruleValue;
                default:
                    return false;
            }
        }
        
        function displaySummary(results, ruleName) {
            const summaryDiv = document.getElementById('summary');
            const { active, matched } = results.totals;
            
            if (matched === active) {
                summaryDiv.innerHTML = `
                    <div class="summary success">
                        ✅ Success: All ${active} active rule conditions matched! Alert would be suppressed by rule "${ruleName}".
                    </div>
                `;
            } else {
                summaryDiv.innerHTML = `
                    <div class="summary failure">
                        ❌ Failure: Only ${matched} of ${active} active rule conditions matched. Alert would NOT be suppressed by rule "${ruleName}".
                    </div>
                `;
            }
        }
        
        function displayMatches(results) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            
            // Display mismatches first (they're more important)
            if (results.mismatches.length > 0) {
                const mismatchHeader = document.createElement('h3');
                mismatchHeader.textContent = "Mismatched Conditions:";
                mismatchHeader.style.color = '#d00';
                resultsDiv.appendChild(mismatchHeader);
                
                results.mismatches.forEach(mismatch => {
                    const mismatchDiv = document.createElement('div');
                    mismatchDiv.className = 'mismatch';
                    
                    const fieldName = fieldMappings[mismatch.field] || mismatch.field;
                    const operatorDisplay = mismatch.operator || '==';
                    
                    mismatchDiv.innerHTML = `
                        <strong>${fieldName}</strong>: ${mismatch.reason}<br>
                        <span style="font-size: 14px">
                            Expected "${mismatch.ruleValue}" ${operatorDisplay} Found "${mismatch.alertValue}"
                        </span>
                    `;
                    
                    resultsDiv.appendChild(mismatchDiv);
                });
            }
            
            // Display matches
            if (results.matches.length > 0) {
                const matchHeader = document.createElement('h3');
                matchHeader.textContent = "Matched Conditions:";
                matchHeader.style.color = '#008000';
                resultsDiv.appendChild(matchHeader);
                
                results.matches.forEach(match => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match';
                    
                    const fieldName = fieldMappings[match.field] || match.field;
                    const operatorDisplay = match.operator || '==';
                    
                    matchDiv.innerHTML = `
                        <strong>${fieldName}</strong>: Match found<br>
                        <span style="font-size: 14px">
                            Rule value "${match.ruleValue}" ${operatorDisplay} Alert value "${match.alertValue}"
                        </span>
                    `;
                    
                    resultsDiv.appendChild(matchDiv);
                });
            }
            
            if (results.matches.length === 0 && results.mismatches.length === 0) {
                resultsDiv.textContent = 'No active rule conditions to evaluate.';
            }
        }
    </script>
</body>
</html>
